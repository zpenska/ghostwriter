'use client';

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  ReactFlow,
  Node,
  Edge,
  addEdge,
  useNodesState,
  useEdgesState,
  Connection,
  Background,
  Controls,
  MiniMap,
  NodeTypes,
  EdgeTypes,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';

// Custom Node Types
import { nodeTypes } from './custom/NodeTypes';

// Firebase imports
import { doc, updateDoc, onSnapshot, getDoc } from 'firebase/firestore';
import { db } from '@/lib/firebase/config';

// Icons
import { 
  Save, 
  RefreshCw, 
  Eye, 
  Loader2, 
  CheckCircle, 
  AlertTriangle,
  Info,
  Zap
} from 'lucide-react';

// Types
interface LogicFlow {
  nodes: Node[];
  edges: Edge[];
  autoGenerated?: boolean;
  lastUpdated: string;
}

interface TemplateComponent {
  id: string;
  type: 'variable' | 'block' | 'component';
  name: string;
  content: string;
  position?: number;
  usageCount: number;
}

interface EnhancedLogicCanvasProps {
  templateId: string;
  templateContent: string;
  onPreviewToggle: () => void;
}

export default function EnhancedLogicCanvas({
  templateId,
  templateContent,
  onPreviewToggle,
}: EnhancedLogicCanvasProps) {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [isAutoGenerating, setIsAutoGenerating] = useState(false);
  const [templateComponents, setTemplateComponents] = useState<TemplateComponent[]>([]);
  const [lastSaved, setLastSaved] = useState<Date | null>(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);

  // Extract template components and variables
  const extractTemplateComponents = useCallback((htmlContent: string): TemplateComponent[] => {
    const components: TemplateComponent[] = [];
    
    // Extract variables {{variable}}
    const variableRegex = /\{\{([^}]+)\}\}/g;
    let match;
    const variableCount: Record<string, number> = {};
    
    while ((match = variableRegex.exec(htmlContent)) !== null) {
      const variableName = match[1].trim();
      variableCount[variableName] = (variableCount[variableName] || 0) + 1;
    }
    
    Object.entries(variableCount).forEach(([name, count]) => {
      components.push({
        id: `var-${name}`,
        type: 'variable',
        name,
        content: `{{${name}}}`,
        usageCount: count,
      });
    });

    // Extract blocks [block:blockName]
    const blockRegex = /\[block:([^\]]+)\]/g;
    const blockCount: Record<string, number> = {};
    
    while ((match = blockRegex.exec(htmlContent)) !== null) {
      const blockName = match[1].trim();
      blockCount[blockName] = (blockCount[blockName] || 0) + 1;
    }
    
    Object.entries(blockCount).forEach(([name, count]) => {
      components.push({
        id: `block-${name}`,
        type: 'block',
        name,
        content: `[block:${name}]`,
        usageCount: count,
      });
    });

    // Extract components <component id="componentId">
    const componentRegex = /<component\s+id="([^"]+)"/g;
    const componentCount: Record<string, number> = {};
    
    while ((match = componentRegex.exec(htmlContent)) !== null) {
      const componentId = match[1].trim();
      componentCount[componentId] = (componentCount[componentId] || 0) + 1;
    }
    
    Object.entries(componentCount).forEach(([id, count]) => {
      components.push({
        id: `comp-${id}`,
        type: 'component',
        name: id,
        content: `<component id="${id}">`,
        usageCount: count,
      });
    });

    return components;
  }, []);

  // Generate unique node ID
  const generateNodeId = useCallback((type: string) => {
    return `${type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }, []);

  // Auto-generate initial logic flow from template
  const autoGenerateLogicFlow = useCallback(async (components: TemplateComponent[]) => {
    if (components.length === 0) return;

    setIsAutoGenerating(true);
    
    try {
      const newNodes: Node[] = [];
      const newEdges: Edge[] = [];
      
      // Add start node
      const startNodeId = generateNodeId('start');
      newNodes.push({
        id: startNodeId,
        type: 'start',
        position: { x: 250, y: 50 },
        data: { label: 'Template Logic Flow' }
      });

      let yPosition = 200;
      let lastNodeId = startNodeId;

      // Group components by type for better organization
      const variableComponents = components.filter(c => c.type === 'variable');
      const blockComponents = components.filter(c => c.type === 'block');
      const componentComponents = components.filter(c => c.type === 'component');

      // Create nodes for high-usage variables (potential conditions)
      variableComponents
        .filter(v => v.usageCount > 1 || ['status', 'type', 'code', 'decision', 'disposition'].some(keyword => 
          v.name.toLowerCase().includes(keyword)))
        .forEach((variable, index) => {
          const nodeId = generateNodeId('condition');
          newNodes.push({
            id: nodeId,
            type: 'condition',
            position: { x: 250, y: yPosition },
            data: {
              label: `Check ${variable.name}`,
              condition: `{{${variable.name}}} !== null`,
              variable: variable.name,
              description: `Conditional logic for ${variable.name}`
            }
          });

          // Add edge from previous node
          newEdges.push({
            id: `edge-${lastNodeId}-${nodeId}`,
            source: lastNodeId,
            target: nodeId,
          });

          lastNodeId = nodeId;
          yPosition += 150;
        });

      // Create component nodes for blocks and components
      [...blockComponents, ...componentComponents].forEach((component, index) => {
        const nodeId = generateNodeId('component');
        newNodes.push({
          id: nodeId,
          type: 'component',
          position: { x: 250, y: yPosition },
          data: {
            label: component.name,
            componentId: component.id,
            componentType: component.type,
            content: component.content,
            usageCount: component.usageCount
          }
        });

        // Add edge from previous node
        newEdges.push({
          id: `edge-${lastNodeId}-${nodeId}`,
          source: lastNodeId,
          target: nodeId,
        });

        lastNodeId = nodeId;
        yPosition += 150;
      });

      // Add healthcare compliance workflow nodes if needed
      const hasStatus = variableComponents.some(v => 
        ['status', 'decision', 'disposition'].some(keyword => v.name.toLowerCase().includes(keyword))
      );

      if (hasStatus) {
        const workflowNodeId = generateNodeId('workflow');
        newNodes.push({
          id: workflowNodeId,
          type: 'workflow',
          position: { x: 250, y: yPosition },
          data: {
            label: 'Healthcare Compliance Check',
            rule: 'Auto-generated Compliance Rules',
            triggerCondition: '{{status}} === "DENIED" || {{decision}} === "ADVERSE"',
            requiredAction: 'Check appeal rights and compliance requirements',
            blockingRule: false,
            autoFix: 'insertComponent("appeal-rights-notice")'
          }
        });

        newEdges.push({
          id: `edge-${lastNodeId}-${workflowNodeId}`,
          source: lastNodeId,
          target: workflowNodeId,
        });
      }

      setNodes(newNodes);
      setEdges(newEdges);
      setHasUnsavedChanges(true);

    } catch (error) {
      console.error('Error auto-generating logic flow:', error);
    } finally {
      setIsAutoGenerating(false);
    }
  }, [setNodes, setEdges, generateNodeId]);

  // Load existing logic or auto-generate
  useEffect(() => {
    const loadLogicFlow = async () => {
      try {
        const templateDoc = await getDoc(doc(db, 'templates', templateId));
        if (templateDoc.exists()) {
          const data = templateDoc.data();
          if (data.logic && data.logic.nodes && data.logic.nodes.length > 0) {
            // Load existing logic
            setNodes(data.logic.nodes);
            setEdges(data.logic.edges || []);
            if (data.logic.lastUpdated) {
              setLastSaved(new Date(data.logic.lastUpdated));
            }
          } else {
            // Auto-generate if no logic exists
            const components = extractTemplateComponents(templateContent);
            setTemplateComponents(components);
            await autoGenerateLogicFlow(components);
          }
        }
      } catch (error) {
        console.error('Error loading logic flow:', error);
      }
    };

    if (templateId && templateContent) {
      loadLogicFlow();
    }
  }, [templateId, templateContent, extractTemplateComponents, autoGenerateLogicFlow, setNodes, setEdges]);

  // Update template components when content changes
  useEffect(() => {
    if (templateContent) {
      const components = extractTemplateComponents(templateContent);
      setTemplateComponents(components);
    }
  }, [templateContent, extractTemplateComponents]);

  // Save logic flow to Firebase
  const saveLogicFlow = useCallback(async () => {
    if (!templateId) return;

    setIsSaving(true);
    setSaveError(null);

    try {
      const logicFlow: LogicFlow = {
        nodes,
        edges,
        autoGenerated: nodes.some(n => n.id.includes('start')),
        lastUpdated: new Date().toISOString(),
      };

      await updateDoc(doc(db, 'templates', templateId), {
        logic: logicFlow,
        updatedAt: new Date().toISOString(),
      });

      setLastSaved(new Date());
      setHasUnsavedChanges(false);
    } catch (error) {
      console.error('Error saving logic flow:', error);
      setSaveError('Failed to save logic flow');
    } finally {
      setIsSaving(false);
    }
  }, [templateId, nodes, edges]);

  // Auto-save on changes (debounced)
  useEffect(() => {
    const timer = setTimeout(() => {
      if (hasUnsavedChanges && !isSaving) {
        saveLogicFlow();
      }
    }, 2000);

    return () => clearTimeout(timer);
  }, [hasUnsavedChanges, saveLogicFlow, isSaving]);

  // Handle node/edge changes
  const onConnect = useCallback((params: Connection) => {
    setEdges((eds) => addEdge(params, eds));
    setHasUnsavedChanges(true);
  }, [setEdges]);

  const handleNodesChange = useCallback((changes: any) => {
    onNodesChange(changes);
    setHasUnsavedChanges(true);
  }, [onNodesChange]);

  const handleEdgesChange = useCallback((changes: any) => {
    onEdgesChange(changes);
    setHasUnsavedChanges(true);
  }, [onEdgesChange]);

  // Regenerate logic flow
  const handleRegenerateFlow = useCallback(async () => {
    const components = extractTemplateComponents(templateContent);
    await autoGenerateLogicFlow(components);
  }, [templateContent, extractTemplateComponents, autoGenerateLogicFlow]);

  // Handle drop events from sidebar
  const onDragOver = useCallback((event: React.DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event: React.DragEvent) => {
      event.preventDefault();

      const reactFlowBounds = event.currentTarget.getBoundingClientRect();
      const type = event.dataTransfer.getData('application/reactflow');

      if (typeof type === 'undefined' || !type) {
        return;
      }

      let nodeData;
      try {
        nodeData = JSON.parse(type);
      } catch (error) {
        console.error('Error parsing dropped data:', error);
        return;
      }

      const position = {
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      };

      const newNode: Node = {
        id: generateNodeId(nodeData.type),
        type: nodeData.type,
        position,
        data: {
          ...nodeData.data,
          label: nodeData.data?.label || `New ${nodeData.type}`
        },
      };

      setNodes((nds) => nds.concat(newNode));
      setHasUnsavedChanges(true);
    },
    [setNodes, generateNodeId]
  );

  // Memoized statistics
  const stats = useMemo(() => ({
    totalNodes: nodes.length,
    totalEdges: edges.length,
    conditionNodes: nodes.filter(n => n.type === 'condition').length,
    componentNodes: nodes.filter(n => n.type === 'component').length,
    workflowNodes: nodes.filter(n => n.type === 'workflow').length,
  }), [nodes, edges]);

  return (
    <div className="h-full flex flex-col bg-white">
      {/* Toolbar */}
      <div className="flex items-center justify-between p-4 border-b bg-gray-50">
        <div className="flex items-center space-x-4">
          <h2 className="text-lg font-semibold text-gray-900">Logic Flow Builder</h2>
          <div className="flex items-center space-x-2 text-sm text-gray-600">
            <span>Components: {templateComponents.length}</span>
            <span>•</span>
            <span>Nodes: {stats.totalNodes}</span>
            <span>•</span>
            <span>Edges: {stats.totalEdges}</span>
            {lastSaved && (
              <>
                <span>•</span>
                <span>Saved: {lastSaved.toLocaleTimeString()}</span>
              </>
            )}
            {hasUnsavedChanges && (
              <span className="text-amber-600">• Unsaved changes</span>
            )}
          </div>
        </div>
        
        <div className="flex items-center space-x-2">
          {/* Auto-generate button */}
          <button
            onClick={handleRegenerateFlow}
            disabled={isAutoGenerating}
            className="flex items-center space-x-2 px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 disabled:opacity-50"
            title="Regenerate logic flow from template"
          >
            {isAutoGenerating ? (
              <Loader2 className="w-4 h-4 animate-spin" />
            ) : (
              <Zap className="w-4 h-4" />
            )}
            <span>{isAutoGenerating ? 'Generating...' : 'Auto-Generate'}</span>
          </button>

          {/* Manual save button */}
          <button
            onClick={saveLogicFlow}
            disabled={!hasUnsavedChanges || isSaving}
            className="flex items-center space-x-2 px-3 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 disabled:opacity-50"
            title="Save logic flow"
          >
            {isSaving ? (
              <Loader2 className="w-4 h-4 animate-spin" />
            ) : (
              <Save className="w-4 h-4" />
            )}
            <span>Save Logic</span>
          </button>

          {/* Preview button */}
          <button
            onClick={onPreviewToggle}
            className="flex items-center space-x-2 px-3 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
            title="Preview template"
          >
            <Eye className="w-4 h-4" />
            <span>Preview</span>
          </button>
        </div>
      </div>

      {/* Error Banner */}
      {saveError && (
        <div className="px-4 py-2 bg-red-50 border-b border-red-200">
          <div className="flex items-center space-x-2">
            <AlertTriangle className="w-4 h-4 text-red-500" />
            <span className="text-sm text-red-700">{saveError}</span>
            <button
              onClick={() => setSaveError(null)}
              className="ml-auto text-red-500 hover:text-red-700"
            >
              ×
            </button>
          </div>
        </div>
      )}

      {/* React Flow Canvas */}
      <div className="flex-1" onDrop={onDrop} onDragOver={onDragOver}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={handleNodesChange}
          onEdgesChange={handleEdgesChange}
          onConnect={onConnect}
          nodeTypes={nodeTypes}
          fitView
          fitViewOptions={{
            padding: 0.2,
          }}
          defaultViewport={{ x: 0, y: 0, zoom: 1 }}
          attributionPosition="bottom-left"
        >
          <Background />
          <Controls />
          <MiniMap 
            nodeStrokeColor={(n) => {
              if (n.type === 'condition') return '#3b82f6';
              if (n.type === 'component') return '#10b981';
              if (n.type === 'workflow') return '#ef4444';
              return '#6b7280';
            }}
            nodeColor={(n) => {
              if (n.type === 'condition') return '#dbeafe';
              if (n.type === 'component') return '#d1fae5';
              if (n.type === 'workflow') return '#fee2e2';
              return '#f3f4f6';
            }}
            maskColor="rgb(240, 242, 246, 0.7)"
          />
        </ReactFlow>
      </div>

      {/* Status Bar */}
      <div className="flex items-center justify-between px-4 py-2 text-xs text-gray-500 bg-gray-50 border-t">
        <div className="flex items-center space-x-4">
          <span>Variables: {templateComponents.filter(c => c.type === 'variable').length}</span>
          <span>Blocks: {templateComponents.filter(c => c.type === 'block').length}</span>
          <span>Components: {templateComponents.filter(c => c.type === 'component').length}</span>
          <span>Conditions: {stats.conditionNodes}</span>
          <span>Workflows: {stats.workflowNodes}</span>
        </div>
        <div className="flex items-center space-x-2">
          {isAutoGenerating && (
            <div className="flex items-center space-x-1 text-blue-600">
              <Loader2 className="w-3 h-3 animate-spin" />
              <span>Auto-generating flow...</span>
            </div>
          )}
          {!isAutoGenerating && hasUnsavedChanges && (
            <div className="flex items-center space-x-1 text-amber-600">
              <AlertTriangle className="w-3 h-3" />
              <span>Unsaved changes</span>
            </div>
          )}
          {!hasUnsavedChanges && lastSaved && (
            <div className="flex items-center space-x-1 text-green-600">
              <CheckCircle className="w-3 h-3" />
              <span>All changes saved</span>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
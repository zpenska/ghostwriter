import { doc, getDoc, collection, getDocs } from 'firebase/firestore';
import { db } from '@/lib/firebase/config';

export interface TemplateData {
  id: string;
  name: string;
  content: string;
  description?: string;
  category?: string;
  tags?: string[];
  createdAt?: string;
  updatedAt?: string;
  createdBy?: string;
  logic?: {
    nodes: any[];
    edges: any[];
    autoGenerated?: boolean;
    healthcareCompliant?: boolean;
    lastUpdated?: string;
  };
  templateComponents?: {
    variables: Array<{
      key: string;
      name: string;
      dataType: string;
      healthcareCategory?: string;
      usageCount: number;
    }>;
    blocks: Array<{
      id: string;
      name: string;
      usageCount: number;
    }>;
    components: Array<{
      id: string;
      name: string;
      usageCount: number;
    }>;
  };
  complianceStatus?: {
    lastChecked?: string;
    violations: any[];
    compliant?: boolean;
  };
  variables?: any[];
  blocks?: any[];
  settings?: {
    enableLogic?: boolean;
    enableCompliance?: boolean;
    autoSave?: boolean;
  };
}

/**
 * Get template data by ID
 */
export async function getTemplateData(templateId: string): Promise<TemplateData> {
  try {
    const templateRef = doc(db, 'templates', templateId);
    const templateSnap = await getDoc(templateRef);

    if (!templateSnap.exists()) {
      throw new Error(`Template with ID ${templateId} not found`);
    }

    const data = templateSnap.data();
    return {
      id: templateSnap.id,
      name: data.name || 'Unnamed Template',
      content: data.content || '',
      description: data.description,
      category: data.category,
      tags: data.tags || [],
      createdAt: data.createdAt?.toDate?.()?.toISOString() || data.createdAt,
      updatedAt: data.updatedAt?.toDate?.()?.toISOString() || data.updatedAt,
      createdBy: data.createdBy,
      logic: data.logic || {
        nodes: [],
        edges: [],
        autoGenerated: false,
        healthcareCompliant: false
      },
      templateComponents: data.templateComponents || {
        variables: [],
        blocks: [],
        components: []
      },
      complianceStatus: data.complianceStatus || {
        violations: [],
        compliant: null
      },
      variables: data.variables || [],
      blocks: data.blocks || [],
      settings: data.settings || {
        enableLogic: true,
        enableCompliance: true,
        autoSave: true
      }
    };
  } catch (error) {
    console.error('Error loading template data:', error);
    throw error;
  }
}

/**
 * Get all templates
 */
export async function getAllTemplates(): Promise<TemplateData[]> {
  try {
    const templatesRef = collection(db, 'templates');
    const templatesSnap = await getDocs(templatesRef);

    return templatesSnap.docs.map(doc => ({
      id: doc.id,
      name: doc.data().name || 'Unnamed Template',
      content: doc.data().content || '',
      description: doc.data().description,
      category: doc.data().category,
      tags: doc.data().tags || [],
      createdAt: doc.data().createdAt?.toDate?.()?.toISOString() || doc.data().createdAt,
      updatedAt: doc.data().updatedAt?.toDate?.()?.toISOString() || doc.data().updatedAt,
      createdBy: doc.data().createdBy,
      logic: doc.data().logic || {
        nodes: [],
        edges: [],
        autoGenerated: false,
        healthcareCompliant: false
      },
      templateComponents: doc.data().templateComponents || {
        variables: [],
        blocks: [],
        components: []
      },
      complianceStatus: doc.data().complianceStatus || {
        violations: [],
        compliant: null
      },
      variables: doc.data().variables || [],
      blocks: doc.data().blocks || [],
      settings: doc.data().settings || {
        enableLogic: true,
        enableCompliance: true,
        autoSave: true
      }
    }));
  } catch (error) {
    console.error('Error loading templates:', error);
    throw error;
  }
}

/**
 * Get templates by category
 */
export async function getTemplatesByCategory(category: string): Promise<TemplateData[]> {
  try {
    const allTemplates = await getAllTemplates();
    return allTemplates.filter(template => template.category === category);
  } catch (error) {
    console.error('Error loading templates by category:', error);
    throw error;
  }
}

/**
 * Get templates with logic flows
 */
export async function getTemplatesWithLogic(): Promise<TemplateData[]> {
  try {
    const allTemplates = await getAllTemplates();
    return allTemplates.filter(template => 
      template.logic && 
      template.logic.nodes && 
      template.logic.nodes.length > 0
    );
  } catch (error) {
    console.error('Error loading templates with logic:', error);
    throw error;
  }
}

/**
 * Get templates with compliance violations
 */
export async function getTemplatesWithViolations(): Promise<TemplateData[]> {
  try {
    const allTemplates = await getAllTemplates();
    return allTemplates.filter(template => 
      template.complianceStatus && 
      template.complianceStatus.violations && 
      template.complianceStatus.violations.length > 0
    );
  } catch (error) {
    console.error('Error loading templates with violations:', error);
    throw error;
  }
}

/**
 * Search templates by content or name
 */
export async function searchTemplates(query: string): Promise<TemplateData[]> {
  try {
    const allTemplates = await getAllTemplates();
    const lowercaseQuery = query.toLowerCase();
    
    return allTemplates.filter(template => 
      template.name.toLowerCase().includes(lowercaseQuery) ||
      template.content.toLowerCase().includes(lowercaseQuery) ||
      (template.description && template.description.toLowerCase().includes(lowercaseQuery)) ||
      (template.tags && template.tags.some(tag => tag.toLowerCase().includes(lowercaseQuery)))
    );
  } catch (error) {
    console.error('Error searching templates:', error);
    throw error;
  }
}

/**
 * Extract template components from content
 */
export function extractTemplateComponents(content: string) {
  const components = {
    variables: [] as Array<{
      key: string;
      name: string;
      usageCount: number;
    }>,
    blocks: [] as Array<{
      id: string;
      name: string;
      usageCount: number;
    }>,
    components: [] as Array<{
      id: string;
      name: string;
      usageCount: number;
    }>
  };

  // Extract variables {{variable}}
  const variableRegex = /\{\{([^}]+)\}\}/g;
  const variableCount: Record<string, number> = {};
  let match;

  while ((match = variableRegex.exec(content)) !== null) {
    const variableName = match[1].trim();
    variableCount[variableName] = (variableCount[variableName] || 0) + 1;
  }

  Object.entries(variableCount).forEach(([key, count]) => {
    components.variables.push({
      key,
      name: key,
      usageCount: count
    });
  });

  // Extract blocks [block:blockName]
  const blockRegex = /\[block:([^\]]+)\]/g;
  const blockCount: Record<string, number> = {};

  while ((match = blockRegex.exec(content)) !== null) {
    const blockName = match[1].trim();
    blockCount[blockName] = (blockCount[blockName] || 0) + 1;
  }

  Object.entries(blockCount).forEach(([name, count]) => {
    components.blocks.push({
      id: name,
      name,
      usageCount: count
    });
  });

  // Extract components <component id="componentId">
  const componentRegex = /<component\s+id="([^"]+)"/g;
  const componentCount: Record<string, number> = {};

  while ((match = componentRegex.exec(content)) !== null) {
    const componentId = match[1].trim();
    componentCount[componentId] = (componentCount[componentId] || 0) + 1;
  }

  Object.entries(componentCount).forEach(([id, count]) => {
    components.components.push({
      id,
      name: id,
      usageCount: count
    });
  });

  return components;
}

/**
 * Get template statistics
 */
export async function getTemplateStatistics() {
  try {
    const allTemplates = await getAllTemplates();
    
    const stats = {
      total: allTemplates.length,
      withLogic: allTemplates.filter(t => (t.logic?.nodes?.length ?? 0) > 0).length,
      withViolations: allTemplates.filter(t => (t.complianceStatus?.violations?.length ?? 0) > 0).length,
      compliant: allTemplates.filter(t => t.complianceStatus?.compliant === true).length,
      categories: {} as Record<string, number>,
      averageVariables: 0,
      averageComponents: 0
    };

    // Calculate category distribution
    allTemplates.forEach(template => {
      const category = template.category || 'Uncategorized';
      stats.categories[category] = (stats.categories[category] || 0) + 1;
    });

    // Calculate averages
    const totalVariables = allTemplates.reduce((sum, t) => 
      sum + (t.templateComponents?.variables?.length || 0), 0
    );
    const totalComponents = allTemplates.reduce((sum, t) => 
      sum + (t.templateComponents?.components?.length || 0), 0
    );

    stats.averageVariables = Math.round(totalVariables / allTemplates.length);
    stats.averageComponents = Math.round(totalComponents / allTemplates.length);

    return stats;
  } catch (error) {
    console.error('Error getting template statistics:', error);
    throw error;
  }
}

/**
 * Validate template data structure
 */
export function validateTemplateData(template: Partial<TemplateData>): string[] {
  const errors: string[] = [];

  if (!template.name || template.name.trim().length === 0) {
    errors.push('Template name is required');
  }

  if (!template.content || template.content.trim().length === 0) {
    errors.push('Template content is required');
  }

  // Validate logic structure if present
  if (template.logic) {
    if (template.logic.nodes && !Array.isArray(template.logic.nodes)) {
      errors.push('Logic nodes must be an array');
    }
    if (template.logic.edges && !Array.isArray(template.logic.edges)) {
      errors.push('Logic edges must be an array');
    }
  }

  // Validate template components if present
  if (template.templateComponents) {
    if (template.templateComponents.variables && !Array.isArray(template.templateComponents.variables)) {
      errors.push('Template variables must be an array');
    }
    if (template.templateComponents.blocks && !Array.isArray(template.templateComponents.blocks)) {
      errors.push('Template blocks must be an array');
    }
    if (template.templateComponents.components && !Array.isArray(template.templateComponents.components)) {
      errors.push('Template components must be an array');
    }
  }

  return errors;
}